#!/bin/sh
#|-*- mode:lisp -*-|#
#|Dump image for faster startup or Make Executable
exec ros -- $0 "$@"
|#

#-ros.util
(ros:include "util")
#-ros.match
(ros:include "match")

(defpackage :ros.dump
  (:use :cl :ros.util :ros.match))
(in-package :ros.dump)

(unless (find-package :uiop)
  #-quicklisp(require :uiop)
  #+quicklisp(ql:quickload :uiop :silent t))

(defun dump-dir ()
  (merge-pathnames (format nil "impls/~A/~A/~A/dump/"
                           (uname-m) (uname) (ros:opt "impl"))
                   (homedir)))

(defun dump-output (params &optional force)
  (flet ((%dump (path &optional mode)
           (if (and (not force)
                    (probe-file path))
               ;; idea??
               ;; (y-or-n-p "Output file exists. Overwrite? [Y,n]")
               (if (eql mode :normal)
                   (format *error-output* "dump ~s already exists~%" (pathname-name path))
                   (format *error-output* "file ~s already exists~%" path))
               (progn
                 #+sbcl
                 (sb-ext:save-lisp-and-die path)
                 #+ccl
                 (ccl:save-application path)))))
    (match params
      (nil
       (format *error-output* "Usage: ~A [OPTIONS] dump output [-f] [-o OUTPUT] NAME~%" (ros:opt "argv0")))
      ((list* "-f" rest)
       (dump-output rest t))
      ((list "-o")
       (format *error-output* "Missing the pathname for an image.~%"))
      ((list* "-o" path rest)
       (%dump path))
      (t (let ((path (merge-pathnames (format nil "~A.~A" (first params) (ros.util:core-extention))
                                      (dump-dir))))
           (%dump (ensure-directories-exist path) :normal))))))

(defun dump-executable (params)
  (match params
    (nil (format *error-output* "Usage: ros dump executable help~%"))
    ((list* out "-o" actual-out _)
     (let ((restart-form
            (or (let ((*read-eval*))
                  ;; should be a form which calls a zero-ary function
                  (read-from-string (format nil "(~A)" (ros:opt "restart"))))
                (warn "dumping an executable without specifing the initial behaviour."))))
       (assert (fboundp (first restart-form)))
       (when (equalp (pathname-type out) "ros")
         (let ((*package* (find-package :cl-user)))
           ;; fixme: document the behavior
           ;; load the file OUT, set ros:*main* to 'main symbol in the last effective package
           (ros:script nil out)
           ;; append "exe" extension for windows environments
           (setf out (make-pathname :type #-win32 nil #+win32 "exe" :defaults actual-out))
           (let ((main-list (let ((*package* (find-package :keyword)))
                              ;; stringify the main function (why?)
                              `((:entry ,(format nil "~S" ros:*main*))))))
             ;; prepend main-list
             (setf restart-form (if restart-form (append restart-form main-list) main-list)))))
       (actually-save-and-die out restart-form)))
    ((list* out _)
     (dump-executable (list out "-o" out)))))

(defun actually-save-and-die (out cmds)
  #+sbcl
  (sb-ext:save-lisp-and-die out
                            :toplevel
                            #'(lambda ()
                                (setf ros:*argv* (rest sb-ext:*posix-argv*))
                                (ros:run cmds))
                            :executable t
                            :save-runtime-options t)
  #+ccl
  (ccl:save-application out
                        :toplevel-function
                        #'(lambda ()
                            (setf ros:*argv* (rest (ccl::command-line-arguments)))
                            (ros:run cmds))
                        :prepend-kernel t))

(defun main (&rest args)
  (declare #+sbcl (sb-ext:muffle-conditions sb-kernel:redefinition-warning cl:style-warning))
  (match args
    ((list* "main" "dump" "output" args)
     (dump-output args))
    #+(or sbcl ccl)
    ((list* "main" "dump" "executable" args)
     (dump-executable args))
    ((list* "main" "dump" x _)
     (format *error-output* "'~A' is not a valid command for '~A' subcommand~%" x cmd))
    (_
     ;; for completion
     (format t "~{~a~%~}" '("output" "executable")))))
