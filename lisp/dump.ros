#!/bin/sh
#|-*- mode:lisp -*-|#
#|Dump image for faster startup or Make Executable
exec ros -- $0 "$@"
|#

#-ros.util
(ros:include "util")
#-ros.match
(ros:include "match")

(defpackage :ros.dump
  (:use :cl :ros.util :ros.match))
(in-package :ros.dump)

(unless (find-package :uiop)
  #-quicklisp(require :uiop)
  #+quicklisp(ql:quickload :uiop :silent t))

(defun dump-dir ()
  (merge-pathnames (format nil "impls/~A/~A/~A/dump/"
                           (uname-m) (uname) (ros:opt "impl"))
                   (homedir)))

(defun dump-output (params &optional force)
  (flet ((%dump (path &optional mode)
           (if (and (not force)
                    (probe-file path))
               ;; idea??
               ;; (y-or-n-p "Output file exists. Overwrite? [Y,n]")
               (if (eql mode :normal)
                   (format *error-output* "dump ~s already exists~%" (pathname-name path))
                   (format *error-output* "file ~s already exists~%" path))
               (progn
                 #+sbcl
                 (sb-ext:save-lisp-and-die path)
                 #+ccl
                 (ccl:save-application path)))))
    (match params
      (nil
       (format *error-output* "Usage: ~A [OPTIONS] dump output [-f] [-o OUTPUT] NAME~%" (ros:opt "argv0")))
      ((list* "-f" rest)
       (dump-output rest t))
      ((list "-o")
       (format *error-output* "Missing the pathname for an image.~%"))
      ((list* "-o" path rest)
       (%dump path))
      (t (let ((path (merge-pathnames (format nil "~A.~A" (first params) (ros.util:core-extention))
                                      (dump-dir))))
           (%dump (ensure-directories-exist path) :normal))))))

(defun dump-executable (params)
  (if (null params)
      (format *error-output* "Usage: ros dump executable help~%")
      (let ((cmds (let ((*read-eval*))
                    (read-from-string
                     (format nil "(~A)"
                             (ros:opt "restart")))))
            (out (first params))
            (actual-out (or (and (equal (second params) "-o") ;; skimped ...
                                 (third params))
                            (first params))))
        (unless cmds
          (warn "dumping an executable without specifing the initial behaviour."))
        (when (equalp (pathname-type out) "ros")
          (let ((*package* (find-package :cl-user))
                main-list)
            (ros:script nil out)
            (setf main-list (let ((*package* (find-package :keyword)))
                              `((:entry ,(format nil "~S" ros:*main*))))
                  out (make-pathname :type #-win32 nil #+win32 "exe" :defaults actual-out)
                  cmds (if (first cmds)
                           (append cmds main-list)
                           main-list))))
        (actually-save-and-die out cmds))))

(defun actually-save-and-die ()
  #+sbcl
  (sb-ext:save-lisp-and-die out
                            :toplevel
                            #'(lambda ()
                                (setf ros:*argv* (rest sb-ext:*posix-argv*))
                                (ros:run cmds))
                            :executable t
                            :save-runtime-options t)
  #+ccl
  (ccl:save-application out
                        :toplevel-function
                        #'(lambda ()
                            (setf ros:*argv* (rest (ccl::command-line-arguments)))
                            (ros:run cmds))
                        :prepend-kernel t))

(defun main (&rest args)
  (match args
    ((list* "main" "dump" "output" args)
     (dump-output args))
    #+(or sbcl ccl)
    ((list* "main" "dump" "executable" args)
     (dump-executable args))
    ((list* "main" "dump" x _)
     (format *error-output* "'~A' is not a valid command for '~A' subcommand~%" x cmd))
    (_
     ;; for completion
     (format t "~{~a~%~}" '("output" "executable")))))
